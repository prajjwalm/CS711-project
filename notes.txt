Notes on Planner:

    1.  There are two important concepts for any person of the Planner population:
        a. how is the work history (X) calculated
        b. what is the distribution of P[work|X]

    2.  For work history calculations to be reasonable, we have to attach exponentially decreasing
        weights to past days. (with a const exp factor: h)
            => X_it = W_i{t-1} + h.X_i{t-1}     for one person
            => X_t = eta_w_{t-1} + h.X_{t-1}    for a population

    3.  To get the macro results (eta_w_t in terms of some aggregate(s) of X_it), compatible with
        micro analysis (P[work]_it for each X_it), we need a very specific distribution of P[work|X]

    4.  If we plan to use X = avg(X_i) as our aggregate, P[work|X] must be linear in X (in [0, 1/1-h))

    5.  Fixing the upper and lower bounds of P[work|X] as 0, 1 doesn't work. This is because of -
        a.  with fixed bounds, all information must come from h, which makes it time-variant. With
            a time-variant h, the formula of 2 doesn't hold. (Imagine h was 0.9 upto t-1, and guy
            keeping track of X in a time variant h requires computing h from the entire history,
            removing any benefits of aggregation, and becoming impossible for part 3)

        b.  with fixed bounds of 0, 1: we have P[work] = 1 - (1 - h)X, we know for symptomatic guys
            P[work] = 0 for all X, but no h can capture this.

    6.  Thus we must have: eta_w = mX + c where m and c are time variant, m <= 0, and the bounds of
        eta_w, ie. [c + m/1-h, c] must be a subset of [0, 1]. Instead of working with m, c, we work
        with the (time variant) bounds themselves, eta_w_min, eta_w_max, with
            eta_w_t = (eta_w_min - eta_w_max) * (1 - h) * X_t + eta_w_max
                where, eta_w_min/max are a function of params and current environment
            also, X_t = eta_w_{t-1} + h.X_{t-1}
        Tracking these two (X and eta_w)_t gives the entire solution.

    7.  Since we are storing the information in the bounds, adding parametric information to h is,
        at best redundant and at worst incorrect. Much better to keep it a constant at data.json.

    8.  The last question that remains is what should the bounds be? The probability that simple
        takes must lie between the bounds. The following seems reasonable -

        Simple   Planner(Max)   Planner(Min)
          95%       97%             93%
          90%       94%             86%
          50%       70%             30%
          10%       14%              6%
           5%        7%              3%


    *.  An important implementation detail is how should X vary in execute_infection()?





        # assuming self.eta_w stores previous day's working ratio
        # Since planner type tries to go to work for a number of target days in a week
        #
        # some way to know avg people who went to work in susceptible population?
        #
        # 0: n0, 1: n1, ...
        # p0*n0 + p1*n1 + ... + p7*n7 (p4 = raghav) p0 > p1 > ... > p7
        #         t     t+1
        # p0=1    n0 -> n0=0
        # p1=1    n1 -> n1=n0
        # p2=1    n2 -> n2=n1
        # p3=0.8  n3 -> n3=n2 + 0.2*n3
        # p4=0.2  n4 -> n4=n3
        # p5=0    n5 ->
        # p6=0    n6 ->
        # p7=0    n7 ->
        #
        # p0..7, n0..7 -> n0..7
        #
        # P[worked exactly 7 days ago] = x
        #
        # n0 = n0*(1-p0) + n1*(1-p1)*x
        # n1 = n0*p0 + n1*(1-p1)*(1 - x) + n1*p1*x + n2*(1-p2)*x
        # n2 = n1*p1 + n2*(1-p2)*(1 - x) + n2*p2*x + n3*(1-p3)*x
        # ...
        # n6 = n5*p5 + n6*(1-p6)*(1 - x) + n6*p6*x + n7*(1-p7)*x
        # n7 = n6*p6 + n7*(1-p7)*(1 - x) + n7*p7*x
        # ________________________________________________________________
        #
        # p = f(x)    -> x is a measure of 'work history'
        # x = [1 if worked yesterday] + [6/7 if worked day before] + ...
        # x(@t+1) = x - [1/7 * n_days worked last week] + [1 if worked yesterday]
        #
        # x = [1 if worked yesterday] + [h if worked day before] + [h^2 ...] + ...
        #
        #
        # x = hx + [1 if worked yesterday] : for one person
        #
        # W.W.H.H.W.W.H
        # x=? (p=0.5)
        # 0|1|1.5|0.75|0.375|1.1875|1.59375|0.796875
        #
        # 1 / (1-h)
        #
        # 1, 2, ..., N=10^10
        # x1, x2, ..., xN
        #
        # E[no. of people working | t=t] = \sum f(xi)
        # E[no. of people working | t=t+1] = \sum f(xi*h + [1 if i worked yesterday])
        #         IF f is linear, f(x) = 1 - (1-h)*x
        #                                  = \sum f(xi)*h + \sum f([1 if i worked yesterday])
        #
        # eta_w = \sum f(xi)*h + \sum f([1 if i worked yesterday else 0])
        # eta_w = eta_w*h + eta_w*f(1) + (1-eta_w)*f(0)
        #       = eta_w*h + eta_w*h + (1-eta_w)
        #       = 1 - eta_w*(1 - 2h)
        #       this works if h < 1/2
        #       otherwise eta_w > 1
        #
        #
        # where p = f(x) in [0,1]
        #
        # wt = 1 - n/7
        # eta_w = N(1-h) - (1-2h)eta_w





        ##########################################################################################################
        #
        # ratio_over_threshold_w = 1 - ((threshold_sw - (1 -(0)*num / unaware_days -  self.fluctuation / 2)) / self.fluctuation)
        # ratio_over_threshold_h = 1 - ((threshold_sh - (1 - self.fluctuation / 2)) / self.fluctuation)
        #
        # w.append(last_w[0] * ratio_over_threshold_w + (1 - last_w[0]) * ratio_over_threshold_h)
        #
        #
        # for i in range(total_days - 1):
        #     if i < unaware_days:
        #         ratio_over_threshold_w = 1 - ((threshold_sw - (1 - (i + 1) / unaware_days - self.fluctuation / 2)) / self.fluctuation)
        #         ratio_over_threshold_w = min(1.0, max(ratio_over_threshold_w, 0))
        #         ratio_over_threshold_h = 1 - (
        #                 (threshold_sh - (1 - (i + 1) / unaware_days - self.fluctuation / 2)) / self.fluctuation)
        #         ratio_over_threshold_h = min(1.0, max(ratio_over_threshold_h, 0))
        #     else:
        #         ratio_over_threshold_w = max((self.fluctuation / 2 - threshold_sw) / self.fluctuation, 0)
        #         ratio_over_threshold_h = max((self.fluctuation / 2 - threshold_sh) / self.fluctuation, 0)
        #     w.append(last_w[i] * ratio_over_threshold_w + (1 - last_w[i]) * ratio_over_threshold_h)

        # ratio_over_threshold_w = 1 - ((threshold_sw - (1 - self.fluctuation / 2)) / self.fluctuation)
        # ratio_over_threshold_h = 1 - ((threshold_sh - (1 - self.fluctuation / 2)) / self.fluctuation)

        # oye @CC ye direct 1 nhi hai??
        # w.append(last_w[total_days] * ratio_over_threshold_w + (1 - last_w[total_days]) * ratio_over_threshold_h)
        # w.append(1)

t = 0

for all types: ratio(W)

t = 1

for all types: ratio(W) ??


TODO BUGS:
    1. sick people don't work in groups, so why raise the chance of infection?

































# info on data.json
    > danger is sqrt death_risk (adjust constant in base player)





# type_shr: periodic?
if len(self.last_week_actions) >= 7:
    self.last_week_actions.pop(0)

assert len(self.action_plan) == 0

cash_work = self.u_economic_w
virus_utility = -self._params["danger"]
death_risk = self.death_risk
active_infection_risk = self.work_infection_risk
passive_infection_risk = self.home_infection_risk
death_utility = self.u_death
health_belief = self.p_healthy
caution_multiplier = 100

# Strategy
# If he hasn't gone to work 4 days in last week, must go to work
# If has gone to work, then compares utility of work and home
# Since he works minimum 4 days a week, is extra cautious about other 3

work = cash_work + virus_utility * active_infection_risk * caution_multiplier + virus_utility * (
        1 - health_belief)

if self.last_week_actions.count("W") < 4:
    action = "W"
    logger.debug("Hasn't gone to work for 4 days in last week, so "
                 "choosing {0}".format(action))
elif work > 0:
    action = "W"
    logger.debug(
            "Working as perceived economic payoff is: {0:.3f}".format(
                    work)
    )
else:
    action = "H"

self.action_plan.append(action)
self.last_week_actions.append(action)


# type ri: linear
class TypeRi(_Person):

    def plan(self):
        if len(self.action_plan) != 0:
            return

        plan_days = 15

        virus_contact_prob_h = 1 - np.power(1 - self.home_infection_risk,
                                            np.arange(plan_days))
        logger.debug("virus contact prob_h = " + str(virus_contact_prob_h))
        virus_contact_prob_w = 1 - np.power(
                1 - (self.home_infection_risk + self.work_infection_risk),
                np.arange(plan_days))
        logger.debug("virus contact prob_w = " + str(virus_contact_prob_w))
        virus_contact_prob_delta = virus_contact_prob_w - virus_contact_prob_h
        logger.debug(
            "virus contact prob_delta = " + str(virus_contact_prob_delta))
        virus_util = virus_contact_prob_delta * self.death_risk * self.u_death
        logger.debug("virus util = " + str(virus_util))
        economic_util = self.u_economic_w * np.arange(plan_days)
        logger.debug("economic util = " + str(economic_util))
        net_util = virus_util + economic_util
        logger.debug(("net util = " + str(net_util)))
        work_days = int(np.argmax(net_util))
        logger.debug("work days = " + str(work_days))

        for i in range(work_days):
            self.action_plan.append("W")
        for i in range(plan_days - work_days):
            self.action_plan.append("H")
